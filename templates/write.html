<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Write a Letter — Simple Letter Detection</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background: #f8fafc; }
    .pad-wrap { max-width: 720px; margin: 2.5rem auto; }
    #draw-pad { background: #fff; border: 1px solid #dee2e6; border-radius: .25rem; touch-action: none; }
    .controls { gap: .5rem; }
    .result { min-height: 3.5rem; border-radius: .25rem; padding: .75rem; background: #fff; border: 1px solid #e9ecef; }
    .small-preview { width: 80px; height: 40px; border:1px solid #ddd; background:#fff; object-fit:contain; }
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-light bg-white border-bottom">
    <div class="container">
      <a class="navbar-brand fw-bold" href="{{ url_for('index') }}">Simple Letter Detection</a>
    </div>
  </nav>

  <main class="container pad-wrap">
    <h2 class="mb-3">Write a letter</h2>
    <p class="text-muted">Draw a letter in the pad below, then submit to run detection.</p>

    <div class="card mb-3">
      <div class="card-body">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <div class="d-flex controls">
            <button id="clearBtn" class="btn btn-sm btn-outline-secondary">Clear</button>
            <button id="startWriteBtn" class="btn btn-sm btn-primary">Write a Letter</button>
            <label class="btn btn-sm btn-outline-secondary mb-0">
              Stroke
              <input id="strokeRange" type="range" min="1" max="30" value="12" style="display:none">
            </label>
          </div>
          <small class="text-muted">Use mouse or touch to draw</small>
        </div>

        <canvas id="draw-pad" width="560" height="280" class="w-100"></canvas>

        <div class="d-flex justify-content-between align-items-center mt-3">
          <div class="d-flex align-items-center gap-2">
            <img id="previewSmall" class="small-preview" alt="preview">
            <small class="text-muted">Sending small preview (8×8) to model</small>
          </div>
          <div>
            <button id="submitBtn" class="btn btn-primary">Submit for Detection</button>
          </div>
        </div>
      </div>
    </div>

    <h5 class="mb-2">Result</h5>
    <div id="result" class="result">
      <div id="resultContent" class="text-muted">No result yet.</div>
    </div>
  </main>

  <script>
    const canvas = document.getElementById('draw-pad');
    const ctx = canvas.getContext('2d');
    const clearBtn = document.getElementById('clearBtn');
    const startWriteBtn = document.getElementById('startWriteBtn');
    const submitBtn = document.getElementById('submitBtn');
    const resultEl = document.getElementById('resultContent');
    const strokeRange = document.getElementById('strokeRange');
    const previewSmall = document.getElementById('previewSmall');

    // scale canvas for high-DPI screens
    function resizeCanvasForHiDPI() {
      const ratio = window.devicePixelRatio || 1;
      const w = canvas.clientWidth || 560;
      const h = canvas.clientHeight || 280;
      if (canvas.width !== w * ratio || canvas.height !== h * ratio) {
        // preserve drawing if any
        const temp = document.createElement('canvas');
        temp.width = canvas.width;
        temp.height = canvas.height;
        temp.getContext('2d').drawImage(canvas, 0, 0);
        canvas.width = w * ratio;
        canvas.height = h * ratio;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.scale(ratio, ratio);
        ctx.drawImage(temp, 0, 0);
      }
    }
    resizeCanvasForHiDPI();
    window.addEventListener('resize', resizeCanvasForHiDPI);

    // drawing state
    let drawing = false;
    let last = { x: 0, y: 0 };
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = strokeRange.value;
    ctx.strokeStyle = '#000';

    strokeRange.addEventListener('input', () => ctx.lineWidth = strokeRange.value);

    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches && e.touches.length) {
        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
      }
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    function begin(e) {
      e.preventDefault();
      drawing = true;
      last = getPos(e);
    }
    function move(e) {
      if (!drawing) return;
      e.preventDefault();
      const p = getPos(e);
      ctx.beginPath();
      ctx.moveTo(last.x, last.y);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      last = p;
    }
    function end(e) {
      if (!drawing) return;
      e.preventDefault();
      drawing = false;
    }

    // mouse
    canvas.addEventListener('mousedown', begin);
    canvas.addEventListener('mousemove', move);
    window.addEventListener('mouseup', end);
    // touch
    canvas.addEventListener('touchstart', begin, { passive: false });
    canvas.addEventListener('touchmove', move, { passive: false });
    window.addEventListener('touchend', end);

    function clearCanvas(msg = 'Canvas cleared.') {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      resultEl.textContent = msg;
      resultEl.classList.remove('text-danger');
      resultEl.classList.add('text-muted');
      previewSmall.src = '';
    }

    clearBtn.addEventListener('click', () => clearCanvas());
    startWriteBtn.addEventListener('click', () => {
      clearCanvas('Draw a letter in the pad below.');
      canvas.scrollIntoView({ behavior: 'smooth', block: 'center' });
    });

    // create a resized dataURL (useful to match model input). target 8x8
    function getResizedDataURL(targetW = 8, targetH = 8) {
      // draw current canvas onto a temporary canvas scaled to target size
      const off = document.createElement('canvas');
      off.width = targetW;
      off.height = targetH;
      const octx = off.getContext('2d');
      // white background to ensure consistent inversion on server
      octx.fillStyle = '#ffffff';
      octx.fillRect(0, 0, targetW, targetH);
      // draw scaled
      octx.drawImage(canvas, 0, 0, targetW, targetH);
      return off.toDataURL('image/png');
    }

    function showSmallPreview(dataURL) {
      previewSmall.src = dataURL;
    }

    // Submit to server via fetch; server should accept JSON {image: dataURL}
    const detectUrl = "{{ url_for('detect') }}";

    submitBtn.addEventListener('click', async () => {
      try {
        // UI loading state
        submitBtn.disabled = true;
        submitBtn.textContent = 'Detecting...';
        resultEl.textContent = 'Preparing image...';
        resultEl.classList.remove('text-danger');

        // prepare small image to send (reduces payload and matches model preprocessing)
        const smallDataURL = getResizedDataURL(8, 8);
        showSmallPreview(smallDataURL);
        resultEl.textContent = 'Sending image to server...';

        const resp = await fetch(detectUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ image: smallDataURL })
        });

        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit for Detection';

        const text = await resp.text();

        if (!resp.ok) {
          // try to show JSON error if server returned JSON text
          try {
            const err = JSON.parse(text);
            resultEl.textContent = 'Server error: ' + (err.error || JSON.stringify(err));
          } catch (_) {
            resultEl.textContent = 'Server error: ' + resp.status + ' — ' + text;
          }
          resultEl.classList.add('text-danger');
          return;
        }

        // Try parse JSON, otherwise accept plain text legacy response
        let json = null;
        try {
          json = JSON.parse(text);
        } catch (_) {
          // server returned plain text prediction (legacy)
          resultEl.innerHTML = `<strong>Letter:</strong> ${text}`;
          resultEl.classList.remove('text-danger');
          return;
        }

        // expected JSON: { letter: 'A', confidence: 0.94 }
        if (json.letter !== undefined) {
          const conf = (typeof json.confidence === 'number') ? (json.confidence * 100).toFixed(1) + '%' : (json.confidence ?? 'n/a');
          resultEl.innerHTML = `<strong>Letter:</strong> ${json.letter} &nbsp; <small class="text-muted">Confidence: ${conf}</small>`;
          resultEl.classList.remove('text-danger');
        } else {
          // if json is a plain value or structure, show it
          resultEl.textContent = 'Unexpected response from server: ' + JSON.stringify(json);
          resultEl.classList.add('text-danger');
        }
      } catch (err) {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit for Detection';
        resultEl.textContent = 'Request failed: ' + err.message;
        resultEl.classList.add('text-danger');
      }
    });
  </script>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>