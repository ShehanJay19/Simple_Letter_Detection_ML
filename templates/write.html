<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Write a Letter — Simple Letter Detection</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background: #f8fafc; }
    .pad-wrap { max-width: 720px; margin: 2.5rem auto; }
    #draw-pad { background: #fff; border: 1px solid #dee2e6; border-radius: .25rem; touch-action: none; }
    .controls { gap: .5rem; }
    .result { min-height: 3.5rem; border-radius: .25rem; padding: .75rem; background: #fff; border: 1px solid #e9ecef; }
    .small-preview { width: 160px; height: 160px; border:1px solid #ddd; background:#fff; display:inline-block; }
  </style>
</head>
<body>
  <main class="container pad-wrap">
    <h2 class="mb-3">Write a letter</h2>

    <div class="card mb-3">
      <div class="card-body">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <div class="d-flex controls">
            <button id="clearBtn" class="btn btn-sm btn-outline-secondary">Clear</button>
            <button id="startWriteBtn" class="btn btn-sm btn-primary">Write a Letter</button>
            <input id="strokeRange" type="range" min="1" max="30" value="12" class="form-range" style="width:120px">
          </div>
          <small class="text-muted">Use mouse or touch to draw</small>
        </div>

        <canvas id="draw-pad" width="560" height="280" class="w-100"></canvas>

        <div class="d-flex justify-content-between align-items-center mt-3">
          <div>
            <div id="previewWrapper" class="small-preview"></div>
            <div class="small text-muted">Preview (upscaled from model input)</div>
          </div>
          <div>
            <button id="submitBtn" class="btn btn-primary">Submit for Detection</button>
          </div>
        </div>
      </div>
    </div>

    <h5 class="mb-2">Result</h5>
    <div id="result" class="result">
      <div id="resultContent" class="text-muted">No result yet.</div>
    </div>
  </main>

  <script>
    const canvas = document.getElementById('draw-pad');
    const ctx = canvas.getContext('2d');
    const clearBtn = document.getElementById('clearBtn');
    const startWriteBtn = document.getElementById('startWriteBtn');
    const submitBtn = document.getElementById('submitBtn');
    const resultEl = document.getElementById('resultContent');
    const strokeRange = document.getElementById('strokeRange');
    const previewWrapper = document.getElementById('previewWrapper');

    // Hi-DPI scaling (keep this if you previously used it)
    (function initHiDPI(){
      const ratio = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth || 560;
      const cssH = canvas.clientHeight || 280;
      canvas.width = cssW * ratio;
      canvas.height = cssH * ratio;
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      ctx.scale(ratio, ratio);
    })();

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.lineWidth = strokeRange.value;
    ctx.strokeStyle = '#000';

    strokeRange.addEventListener('input', () => ctx.lineWidth = strokeRange.value);

    let drawing = false, last = {x:0,y:0};
    function getPos(e){
      const r = canvas.getBoundingClientRect();
      const t = (e.touches && e.touches[0]) || e;
      return { x: t.clientX - r.left, y: t.clientY - r.top };
    }
    function begin(e){ e.preventDefault(); drawing=true; last=getPos(e); }
    function move(e){ if(!drawing) return; e.preventDefault(); const p=getPos(e); ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(p.x,p.y); ctx.stroke(); last=p; }
    function end(e){ if(!drawing) return; e.preventDefault(); drawing=false; }

    canvas.addEventListener('mousedown', begin);
    canvas.addEventListener('mousemove', move);
    window.addEventListener('mouseup', end);
    canvas.addEventListener('touchstart', begin, {passive:false});
    canvas.addEventListener('touchmove', move, {passive:false});
    window.addEventListener('touchend', end);

    function clearCanvas(msg='Canvas cleared.'){
      // clear logical drawing area (use CSS size to clear)
      const r = canvas.getBoundingClientRect();
      ctx.clearRect(0,0,r.width,r.height);
      // paint white background so exported PNG has white bg
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,r.width,r.height);
      resultEl.textContent = msg;
      resultEl.classList.remove('text-danger');
      previewWrapper.innerHTML = '';
    }

    clearBtn.addEventListener('click', () => clearCanvas());
    startWriteBtn.addEventListener('click', () => { clearCanvas('Draw a letter in the pad below.'); canvas.scrollIntoView({behavior:'smooth', block:'center'}); });

    // create a resized dataURL reliably: use canvas.toDataURL as source then draw that image into a tiny canvas
    function getResizedDataURL(targetW=8, targetH=8){
      return new Promise(resolve => {
        // ensure exported image has white background: draw onto temp canvas
        const srcData = canvas.toDataURL('image/png');
        const img = new Image();
        img.onload = () => {
          const off = document.createElement('canvas');
          off.width = targetW;
          off.height = targetH;
          const octx = off.getContext('2d');
          // white background
          octx.fillStyle = '#ffffff';
          octx.fillRect(0,0,targetW,targetH);
          // draw scaled from the exported image (this avoids backing-store size issues)
          octx.drawImage(img, 0, 0, targetW, targetH);
          resolve(off.toDataURL('image/png'));
        };
        img.src = srcData;
      });
    }

    // show an upscaled pixel-preview without smoothing so humans see exact pixels model receives
    function showUpscaledPreview(smallDataURL, scale=20){
      previewWrapper.innerHTML = '';
      const img = new Image();
      img.onload = () => {
        const srcW = img.width, srcH = img.height;
        const pv = document.createElement('canvas');
        pv.width = srcW * scale;
        pv.height = srcH * scale;
        const pctx = pv.getContext('2d');
        pctx.imageSmoothingEnabled = false;
        pctx.fillStyle = '#ffffff';
        pctx.fillRect(0,0,pv.width,pv.height);
        pctx.drawImage(img, 0, 0, pv.width, pv.height);
        previewWrapper.appendChild(pv);
      };
      img.src = smallDataURL;
    }

    const detectUrl = "{{ url_for('detect') }}";

    submitBtn.addEventListener('click', async () => {
      try{
        submitBtn.disabled = true;
        submitBtn.textContent = 'Detecting...';
        resultEl.textContent = 'Preparing image...';
        // build 8x8 payload
        const smallDataURL = await getResizedDataURL(8,8);
        // show human preview (upscaled nearest-neighbor)
        showUpscaledPreview(smallDataURL, 20);

        resultEl.textContent = 'Sending image to server...';
        const resp = await fetch(detectUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ image: smallDataURL })
        });

        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit for Detection';
        const text = await resp.text();

        if (!resp.ok){
          try { const err = JSON.parse(text); resultEl.textContent = 'Server error: ' + (err.error || JSON.stringify(err)); }
          catch { resultEl.textContent = 'Server error: ' + resp.status + ' — ' + text; }
          resultEl.classList.add('text-danger');
          return;
        }

        let json = null;
        try { json = JSON.parse(text); }
        catch { resultEl.innerHTML = `<strong>Letter:</strong> ${text}`; resultEl.classList.remove('text-danger'); return; }

        if (json.letter !== undefined){
          const conf = (typeof json.confidence === 'number') ? (json.confidence * 100).toFixed(1) + '%' : (json.confidence ?? 'n/a');
          resultEl.innerHTML = `<strong>Letter:</strong> ${json.letter} &nbsp; <small class="text-muted">Confidence: ${conf}</small>`;
          resultEl.classList.remove('text-danger');
        } else {
          resultEl.textContent = 'Unexpected response from server: ' + JSON.stringify(json);
          resultEl.classList.add('text-danger');
        }
      } catch (err){
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit for Detection';
        resultEl.textContent = 'Request failed: ' + err.message;
        resultEl.classList.add('text-danger');
      }
    });

    // initialize with white background
    clearCanvas('Draw a letter in the pad below.');
  </script>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>